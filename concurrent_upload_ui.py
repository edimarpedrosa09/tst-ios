"""
Interface de Upload Simult√¢neo - VERS√ÉO COM SINTAXE CORRIGIDA
Arquivo: concurrent_upload_ui.py
Gerencia interface para m√∫ltiplos uploads simult√¢neos com corre√ß√£o de metadados
"""
import streamlit as st
import time
from datetime import datetime
from typing import List, Dict
import logging

logger = logging.getLogger(__name__)

class ConcurrentUploadUI:
    """Interface para gerenciar uploads simult√¢neos - VERS√ÉO CORRIGIDA"""
    
    def __init__(self, s3_concurrent_manager, db_manager):
        self.s3_manager = s3_concurrent_manager
        self.db_manager = db_manager
        
        # CORRE√á√ÉO: Verificar se concurrent_manager existe antes de usar
        if hasattr(s3_concurrent_manager, 'concurrent_manager'):
            self.concurrent_manager = s3_concurrent_manager.concurrent_manager
        else:
            self.concurrent_manager = None
            logger.warning("Concurrent manager not available - using basic upload")
    
    def render_upload_section(self, username: str):
        """Renderiza se√ß√£o principal de upload"""
        
        # CORRE√á√ÉO: Verificar se concurrent manager est√° dispon√≠vel
        if not self.concurrent_manager:
            st.warning("‚ö†Ô∏è Sistema de uploads simult√¢neos indispon√≠vel")
            st.info("Usando sistema b√°sico de upload...")
            self._render_basic_upload_fallback(username)
            return
        
        st.header("üì§ Espa√ßo Para Upload de Arquivos")
        
        # Status geral do sistema
        self._render_system_status()
        
        # √Årea de upload m√∫ltiplo
        self._render_multi_upload_area(username)
        
        # Monitor de uploads ativos
        self._render_active_uploads_monitor()
        
        # Hist√≥rico e estat√≠sticas
        self._render_upload_history()
        
        # Se√ß√£o de sincroniza√ß√£o de metadados
        self._render_metadata_sync_section(username)
    
    def _render_system_status(self):
        """Renderiza status geral do sistema"""
        try:
            stats = self.concurrent_manager.get_system_statistics()
            
            st.subheader("üìä Status do Sistema")
            
            # M√©tricas principais
            col1, col2, col3, col4, col5 = st.columns(5)
            
            with col1:
                st.metric(
                    "Uploads Ativos", 
                    stats.get('active_uploads', 0),
                    f"M√°x: {stats.get('max_concurrent', 10)}"
                )
            
            with col2:
                st.metric(
                    "Enviando Agora", 
                    stats.get('uploading_now', 0),
                    f"de {stats.get('max_concurrent', 10)}"
                )
            
            with col3:
                st.metric(
                    "Na Fila", 
                    stats.get('queued_uploads', 0)
                )
            
            with col4:
                st.metric(
                    "Conclu√≠dos", 
                    stats.get('completed_uploads', 0)
                )
            
            with col5:
                failed_count = stats.get('failed_uploads', 0)
                if failed_count > 0:
                    st.metric(
                        "Falharam", 
                        failed_count,
                        delta=f"-{failed_count}"
                    )
                else:
                    st.metric("Falharam", 0)
            
            # Barra de utiliza√ß√£o
            max_concurrent = stats.get('max_concurrent', 1)
            uploading_now = stats.get('uploading_now', 0)
            
            if max_concurrent > 0:
                utilization = (uploading_now / max_concurrent) * 100
                st.progress(utilization / 100)
                st.caption(f"Utiliza√ß√£o: {utilization:.1f}% ({uploading_now}/{max_concurrent} slots)")
            
        except Exception as e:
            st.error(f"Erro ao carregar status do sistema: {e}")
            logger.error(f"System status error: {e}")
    
    def _render_multi_upload_area(self, username: str):
        """Renderiza √°rea de upload m√∫ltiplo"""
        st.subheader("üìÅ Selecionar Arquivos")
        
        # Upload m√∫ltiplo
        uploaded_files = st.file_uploader(
            "Escolha um ou mais arquivos:",
            accept_multiple_files=True,
            type=None,
            help="Selecione m√∫ltiplos arquivos para upload simult√¢neo"
        )
        
        if uploaded_files:
            self._render_file_selection_area(uploaded_files, username)
    
    def _render_file_selection_area(self, uploaded_files: List, username: str):
        """Renderiza √°rea de sele√ß√£o e configura√ß√£o de arquivos"""
        st.write(f"### üìÑ {len(uploaded_files)} Arquivo(s) Selecionado(s)")
        
        # Valida√ß√µes gerais
        max_file_size = 2 * 1024 * 1024 * 1024  # 2GB
        oversized_files = [f for f in uploaded_files if f.size > max_file_size]
        
        if oversized_files:
            st.error(f"‚ùå {len(oversized_files)} arquivo(s) muito grande(s) (m√°ximo 2GB)")
            return
        
        # Lista de arquivos com configura√ß√µes
        files_config = []
        
        for i, file in enumerate(uploaded_files):
            with st.container():
                col1, col2, col3, col4 = st.columns([3, 1, 1, 1])
                
                with col1:
                    st.write(f"**{file.name}**")
                    size_mb = file.size / (1024 * 1024)
                    if size_mb >= 1024:
                        size_display = f"{size_mb/1024:.2f} GB"
                    else:
                        size_display = f"{size_mb:.1f} MB"
                    
                    st.caption(f"üìä {size_display} ‚Ä¢ {file.type or 'Tipo desconhecido'}")
                
                with col2:
                    # Prioridade
                    priority = st.selectbox(
                        "Prioridade",
                        [1, 2, 3],
                        format_func=lambda x: {1: "üî¥ Alta", 2: "üü° Normal", 3: "üü¢ Baixa"}[x],
                        index=1,  # Normal por padr√£o
                        key=f"priority_{i}"
                    )
                
                with col3:
                    # Nome √∫nico ser√° gerado automaticamente
                    try:
                        unique_name, _ = self.concurrent_manager.generate_unique_filename(file.name, username)
                        if unique_name != file.name:
                            st.caption(f"üìù Ser√° salvo como:")
                            st.caption(f"**{unique_name}**")
                        else:
                            st.caption("‚úÖ Nome original")
                    except Exception as e:
                        logger.error(f"Error generating unique name: {e}")
                        unique_name = file.name
                        st.caption("‚úÖ Nome original")
                
                with col4:
                    # Incluir no upload
                    include = st.checkbox(
                        "Incluir",
                        value=True,
                        key=f"include_{i}"
                    )
                
                if include:
                    files_config.append({
                        'file': file,
                        'priority': priority,
                        'unique_name': unique_name
                    })
                
                st.divider()
        
        # Resumo e bot√£o de upload
        if files_config:
            selected_count = len(files_config)
            
            col1, col2 = st.columns([2, 1])
            
            with col1:
                st.write(f"**üìã Resumo: {selected_count} arquivo(s) selecionado(s)**")
            
            with col2:
                # Bot√£o de upload
                if st.button("üöÄ Iniciar Uploads", type="primary", use_container_width=True):
                    self._start_batch_upload(files_config, username)
    
    def _start_batch_upload(self, files_config: List[Dict], username: str):
        """Inicia batch de uploads"""
        try:
            upload_ids = []
            
            for config in files_config:
                file_obj = config['file']
                priority = config['priority']
                
                # Iniciar upload
                upload_id = self.s3_manager.upload_file_concurrent(
                    file_obj=file_obj,
                    file_name=file_obj.name,
                    username=username,
                    priority=priority
                )
                
                upload_ids.append(upload_id)
                logger.info(f"Started upload: {upload_id} for {file_obj.name}")
            
            # Feedback de sucesso
            st.success(f"‚úÖ {len(upload_ids)} upload(s) iniciado(s)!")
            st.info("üëÅÔ∏è Acompanhe o progresso na se√ß√£o de monitoramento abaixo")
            
            # Rerun para atualizar interface
            time.sleep(1)
            st.rerun()
            
        except Exception as e:
            st.error(f"‚ùå Erro ao iniciar uploads: {str(e)}")
            logger.error(f"Batch upload error: {e}")
    
    def _render_active_uploads_monitor(self):
        """Renderiza monitor de uploads ativos"""
        try:
            active_uploads = self.concurrent_manager.get_all_active_uploads()
            
            if not active_uploads:
                st.info("üí§ Nenhum upload ativo no momento")
                return
            
            st.subheader(f"üîÑ Uploads Ativos ({len(active_uploads)})")
            
            # Container para atualiza√ß√µes em tempo real
            monitor_container = st.container()
            
            with monitor_container:
                for session in active_uploads:
                    self._render_upload_progress_card(session)
            
            # Auto-refresh
            if active_uploads:
                time.sleep(2)
                st.rerun()
                
        except Exception as e:
            st.error(f"Erro ao carregar uploads ativos: {e}")
            logger.error(f"Active uploads monitor error: {e}")
    
    def _render_upload_progress_card(self, session):
        """Renderiza card de progresso individual"""
        try:
            with st.container():
                # Header do card
                col1, col2, col3 = st.columns([3, 1, 1])
                
                with col1:
                    # Status icon baseado no status
                    status_icons = {
                        'initializing': 'üîÑ',
                        'queued': '‚è≥',
                        'uploading': 'üì§',
                        'completed': '‚úÖ',
                        'failed': '‚ùå',
                        'cancelled': 'üö´'
                    }
                    
                    icon = status_icons.get(session.status, '‚ùì')
                    st.write(f"{icon} **{session.file_name}**")
                
                with col2:
                    # Prioridade
                    priority_display = {1: "üî¥ Alta", 2: "üü° Normal", 3: "üü¢ Baixa"}
                    st.caption(f"Prioridade: {priority_display.get(session.priority, 'N/A')}")
                
                with col3:
                    # A√ß√µes
                    if session.status in ['uploading', 'queued']:
                        if st.button("‚ùå Cancelar", key=f"cancel_{session.id}", use_container_width=True):
                            if self.concurrent_manager.cancel_upload(session.id):
                                st.success("Upload cancelado!")
                                st.rerun()
                
                # Progresso detalhado
                if session.status == 'uploading':
                    # Barra de progresso
                    progress = getattr(session, 'progress_percentage', 0) / 100
                    st.progress(progress)
                    
                    # M√©tricas b√°sicas
                    st.caption(f"Progresso: {getattr(session, 'progress_percentage', 0):.1f}%")
                    st.caption(f"Velocidade: {getattr(session, 'speed_mbps', 0):.1f} MB/s")
                
                st.markdown("---")
                
        except Exception as e:
            st.error(f"Erro ao renderizar progresso: {e}")
            logger.error(f"Progress card error: {e}")
    
    def _render_upload_history(self):
        """Renderiza hist√≥rico de uploads"""
        try:
            st.subheader("üìö Hist√≥rico de Uploads")
            
            # Tabs para diferentes categorias
            tab1, tab2 = st.tabs(["‚úÖ Conclu√≠dos", "‚ùå Falharam"])
            
            with tab1:
                self._render_completed_uploads()
            
            with tab2:
                self._render_failed_uploads()
                
        except Exception as e:
            st.error(f"Erro ao carregar hist√≥rico: {e}")
            logger.error(f"Upload history error: {e}")
    
    def _render_completed_uploads(self):
        """Renderiza uploads conclu√≠dos"""
        try:
            completed = list(self.concurrent_manager.completed_uploads.values())
            
            if not completed:
                st.info("üìÇ Nenhum upload conclu√≠do nesta sess√£o")
                return
            
            # Ordenar por mais recente
            completed.sort(key=lambda x: x.start_time, reverse=True)
            
            st.write(f"**{len(completed)} upload(s) conclu√≠do(s)**")
            
            for session in completed[:10]:  # Mostrar √∫ltimos 10
                with st.expander(f"‚úÖ {session.file_name}", expanded=False):
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.write(f"**Arquivo:** {getattr(session, 'original_file_name', session.file_name)}")
                        st.write(f"**Tamanho:** {self._format_bytes(session.file_size)}")
                        
                        # Bot√£o para salvar metadados
                        if not getattr(session, 'metadata_saved', False):
                            if st.button(f"üíæ Concluir Upload", key=f"save_meta_{session.id}"):
                                if self._save_file_metadata(session):
                                    session.metadata_saved = True
                                    st.success("‚úÖ Arquivos salvos!")
                                    st.rerun()
                                else:
                                    st.error("‚ùå Erro ao salvar metadados")
                        else:
                            st.success("‚úÖ Metadados j√° salvos no banco")
                    
                    with col2:
                        # Calcular estat√≠sticas
                        if hasattr(session, 'start_time'):
                            end_time = getattr(session, 'end_time', time.time())
                            total_time = end_time - session.start_time
                            speed = (session.file_size / (1024 * 1024)) / total_time if total_time > 0 else 0
                            
                            st.write(f"**Velocidade:** {speed:.1f} MB/s")
                            st.write(f"**Tempo:** {self._format_time(total_time)}")
                            
        except Exception as e:
            st.error(f"Erro ao carregar uploads conclu√≠dos: {e}")
            logger.error(f"Completed uploads error: {e}")
    
    def _render_failed_uploads(self):
        """Renderiza uploads falhados"""
        try:
            failed = list(self.concurrent_manager.failed_uploads.values())
            
            if not failed:
                st.success("üéâ Nenhum upload falhado!")
                return
            
            st.write(f"**{len(failed)} upload(s) falharam**")
            
            for session in failed:
                with st.expander(f"‚ùå {session.file_name}", expanded=False):
                    error_msg = getattr(session, 'error_message', 'Erro desconhecido')
                    st.error(f"**Erro:** {error_msg}")
                    st.write(f"**Arquivo:** {getattr(session, 'original_file_name', session.file_name)}")
                    
        except Exception as e:
            st.error(f"Erro ao carregar uploads falhados: {e}")
            logger.error(f"Failed uploads error: {e}")
    
    def _render_metadata_sync_section(self, username: str):
        """Se√ß√£o para sincroniza√ß√£o de metadados"""
        try:
            st.subheader("üîÑ Sincroniza√ß√£o de Metadados")
            
            with st.expander("üíæ Garantir que arquivos apare√ßam em 'Meus Arquivos'", expanded=False):
                st.write("""
                **Por que usar esta se√ß√£o?**
                - √Äs vezes os uploads simult√¢neos completam mas os metadados n√£o s√£o salvos no banco
                - Isso faz com que os arquivos existam no S3 mas n√£o apare√ßam em "Meus Arquivos"
                - Use as ferramentas abaixo para sincronizar
                """)
                
                col1, col2 = st.columns(2)
                
                with col1:
                    if st.button("üîÑ Sincronizar Uploads Conclu√≠dos", use_container_width=True):
                        self._sync_completed_uploads()
                
                with col2:
                    if st.button("üîç Buscar Arquivos √ìrf√£os no S3", use_container_width=True):
                        self._find_orphaned_files(username)
                        
        except Exception as e:
            st.error(f"Erro na se√ß√£o de metadados: {e}")
            logger.error(f"Metadata sync error: {e}")
    
    def _sync_completed_uploads(self):
        """Sincroniza uploads conclu√≠dos que n√£o salvaram metadados"""
        try:
            completed = list(self.concurrent_manager.completed_uploads.values())
            
            if not completed:
                st.info("üìÇ Nenhum upload conclu√≠do para sincronizar")
                return
            
            synced_count = 0
            
            for session in completed:
                if not getattr(session, 'metadata_saved', False):
                    try:
                        if self._save_file_metadata(session):
                            session.metadata_saved = True
                            synced_count += 1
                            st.write(f"‚úÖ Sincronizado: {getattr(session, 'original_file_name', session.file_name)}")
                    except Exception as e:
                        st.write(f"‚ùå Erro em {getattr(session, 'original_file_name', session.file_name)}: {str(e)}")
            
            if synced_count > 0:
                st.success(f"üéâ {synced_count} arquivo(s) sincronizado(s)!")
            else:
                st.info("‚ÑπÔ∏è Todos os uploads j√° est√£o sincronizados")
                    
        except Exception as e:
            st.error(f"Erro na sincroniza√ß√£o: {e}")
            logger.error(f"Sync completed uploads error: {e}")
    
    def _find_orphaned_files(self, username: str):
        """Busca arquivos √≥rf√£os no S3 que n√£o est√£o no banco"""
        try:
            import boto3
            
            # Usar as credenciais do S3Manager
            s3_client = self.s3_manager.s3_manager.s3_client
            bucket = self.s3_manager.s3_manager.bucket
            
            # Listar arquivos do usu√°rio no S3
            prefix = f"{username}/"
            
            with st.spinner("üîç Buscando arquivos √≥rf√£os..."):
                response = s3_client.list_objects_v2(
                    Bucket=bucket,
                    Prefix=prefix
                )
                
                if 'Contents' not in response:
                    st.info("üìÇ Nenhum arquivo encontrado no S3")
                    return
                
                s3_files = response['Contents']
                
                # Verificar quais n√£o est√£o no banco
                conn = self.db_manager.get_connection()
                cursor = conn.cursor()
                
                orphaned_files = []
                
                for s3_file in s3_files:
                    file_key = s3_file['Key']
                    
                    cursor.execute("SELECT COUNT(*) FROM files WHERE file_key = %s", (file_key,))
                    exists = cursor.fetchone()[0] > 0
                    
                    if not exists:
                        orphaned_files.append({
                            'file_key': file_key,
                            'size': s3_file['Size'],
                            'last_modified': s3_file['LastModified']
                        })
                
                cursor.close()
                conn.close()
                
                if orphaned_files:
                    st.warning(f"‚ö†Ô∏è Encontrados {len(orphaned_files)} arquivo(s) √≥rf√£o(s):")
                    
                    for file_info in orphaned_files:
                        file_key = file_info['file_key']
                        original_name = file_key.split('/')[-1]
                        
                        # Remover timestamp se presente
                        if '_' in original_name:
                            parts = original_name.split('_', 1)
                            if len(parts) > 1:
                                original_name = parts[1]
                        
                        col1, col2 = st.columns([3, 1])
                        
                        with col1:
                            st.write(f"üìÑ **{original_name}**")
                            st.caption(f"S3: {file_key}")
                            st.caption(f"Tamanho: {self._format_bytes(file_info['size'])}")
                        
                        with col2:
                            if st.button(f"üíæ Adicionar", key=f"add_{file_key}", use_container_width=True):
                                try:
                                    # Detectar MIME type
                                    import mimetypes
                                    mime_type, _ = mimetypes.guess_type(original_name)
                                    if not mime_type:
                                        mime_type = "application/octet-stream"
                                    
                                    # Salvar no banco
                                    self.db_manager.save_file_metadata(
                                        file_key=file_key,
                                        original_name=original_name,
                                        file_size=file_info['size'],
                                        username=username,
                                        mime_type=mime_type
                                    )
                                    
                                    st.success(f"‚úÖ {original_name} adicionado!")
                                    st.rerun()
                                    
                                except Exception as e:
                                    st.error(f"‚ùå Erro: {str(e)}")
                        
                        st.divider()
                else:
                    st.success("‚úÖ Todos os arquivos est√£o sincronizados!")
                    
        except Exception as e:
            st.error(f"‚ùå Erro ao buscar arquivos √≥rf√£os: {str(e)}")
            logger.error(f"Orphaned files search error: {e}")
    
    def _save_file_metadata(self, session):
        """Salva metadados do arquivo no banco"""
        try:
            # Verificar se session tem todos os dados necess√°rios
            if not hasattr(session, 'file_key') or not session.file_key:
                logger.error(f"Session {session.id} missing file_key")
                return False
                
            original_file_name = getattr(session, 'original_file_name', session.file_name)
            if not original_file_name:
                logger.error(f"Session {session.id} missing original_file_name")
                return False
                
            if not hasattr(session, 'file_size') or not session.file_size:
                logger.error(f"Session {session.id} missing file_size")
                return False
                
            if not hasattr(session, 'username') or not session.username:
                logger.error(f"Session {session.id} missing username")
                return False

            # Salvar no banco
            self.db_manager.save_file_metadata(
                file_key=session.file_key,
                original_name=original_file_name,
                file_size=session.file_size,
                username=session.username,
                mime_type=getattr(session, 'file_type', None) or "application/octet-stream"
            )
            
            logger.info(f"‚úÖ Metadata saved successfully for: {session.file_key}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error saving metadata for session {session.id}: {e}")
            return False
    
    def _render_basic_upload_fallback(self, username: str):
        """Fallback para upload b√°sico"""
        st.header("üì§ Upload de Arquivo")
        
        uploaded_file = st.file_uploader("Escolha um arquivo:", type=None)
        
        if uploaded_file is not None:
            if st.button("üöÄ Fazer Upload", type="primary"):
                try:
                    # Gerar nome √∫nico simples
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    file_key = f"{username}/{timestamp}_{uploaded_file.name}"
                    
                    with st.spinner("Fazendo upload..."):
                        # Upload
                        if self.s3_manager.upload_file(uploaded_file, file_key):
                            # Salvar metadados
                            self.db_manager.save_file_metadata(
                                file_key=file_key,
                                original_name=uploaded_file.name,
                                file_size=uploaded_file.size,
                                username=username,
                                mime_type=uploaded_file.type or "application/octet-stream"
                            )
                            
                            st.success("‚úÖ Upload conclu√≠do!")
                            st.balloons()
                        else:
                            st.error("‚ùå Falha no upload")
                            
                except Exception as e:
                    st.error(f"‚ùå Erro: {str(e)}")
    
    def _format_bytes(self, bytes_value: int) -> str:
        """Formata bytes para leitura humana"""
        if bytes_value < 1024:
            return f"{bytes_value} B"
        elif bytes_value < 1024 * 1024:
            return f"{bytes_value / 1024:.1f} KB"
        elif bytes_value < 1024 * 1024 * 1024:
            return f"{bytes_value / (1024 * 1024):.1f} MB"
        else:
            return f"{bytes_value / (1024 * 1024 * 1024):.2f} GB"
    
    def _format_time(self, seconds: float) -> str:
        """Formata tempo para leitura humana"""
        if seconds < 60:
            return f"{seconds:.0f}s"
        elif seconds < 3600:
            return f"{seconds / 60:.0f}m {seconds % 60:.0f}s"
        else:
            hours = seconds // 3600
            minutes = (seconds % 3600) // 60
            return f"{hours:.0f}h {minutes:.0f}m"


# Fun√ß√£o principal para integra√ß√£o - VERS√ÉO CORRIGIDA
def render_concurrent_upload_section(s3_manager, db_manager, username: str):
    """Renderiza se√ß√£o completa de upload simult√¢neo - VERS√ÉO CORRIGIDA"""
    try:
        # CORRE√á√ÉO: Importa√ß√£o condicional e tratamento de erro
        try:
            from enhanced_upload_monitor import get_s3_concurrent_manager
            
            # Obter manager de uploads simult√¢neos
            s3_concurrent_manager = get_s3_concurrent_manager(s3_manager)
            
            # Criar e renderizar UI
            upload_ui = ConcurrentUploadUI(s3_concurrent_manager, db_manager)
            upload_ui.render_upload_section(username)
            
        except ImportError as import_error:
            logger.warning(f"Enhanced upload monitor not available: {import_error}")
            # Fallback para upload b√°sico
            st.warning("‚ö†Ô∏è Sistema de upload simult√¢neo n√£o dispon√≠vel")
            st.info("Usando sistema b√°sico de upload...")
            _render_basic_upload_fallback(s3_manager, db_manager, username)
            
        except Exception as enhanced_error:
            logger.error(f"Enhanced upload system error: {enhanced_error}")
            # Fallback para upload b√°sico em caso de qualquer erro
            st.warning("‚ö†Ô∏è Erro no sistema de upload avan√ßado")
            st.info("Usando sistema b√°sico de upload como fallback...")
            _render_basic_upload_fallback(s3_manager, db_manager, username)
        
    except Exception as e:
        logger.error(f"Critical error in concurrent upload section: {e}")
        st.error(f"‚ùå Erro cr√≠tico no sistema de upload: {str(e)}")
        
        # √öltimo fallback - upload b√°sico m√≠nimo
        st.info("Tentando sistema b√°sico de emerg√™ncia...")
        _render_emergency_upload_fallback(s3_manager, db_manager, username)


def _render_basic_upload_fallback(s3_manager, db_manager, username: str):
    """Fallback para upload b√°sico"""
    st.header("üì§ Upload de Arquivo")
    
    uploaded_file = st.file_uploader("Escolha um arquivo:", type=None)
    
    if uploaded_file is not None:
        # Mostrar informa√ß√µes do arquivo
        st.write(f"**Nome:** {uploaded_file.name}")
        st.write(f"**Tamanho:** {uploaded_file.size:,} bytes")
        st.write(f"**Tipo:** {uploaded_file.type or 'Desconhecido'}")
        
        if st.button("üöÄ Fazer Upload", type="primary"):
            try:
                # Gerar nome √∫nico simples
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                file_key = f"{username}/{timestamp}_{uploaded_file.name}"
                
                with st.spinner("Fazendo upload..."):
                    # Upload
                    if s3_manager.upload_file(uploaded_file, file_key):
                        # Salvar metadados
                        db_manager.save_file_metadata(
                            file_key=file_key,
                            original_name=uploaded_file.name,
                            file_size=uploaded_file.size,
                            username=username,
                            mime_type=uploaded_file.type or "application/octet-stream"
                        )
                        
                        st.success("‚úÖ Upload conclu√≠do!")
                        st.balloons()
                    else:
                        st.error("‚ùå Falha no upload")
                        
            except Exception as e:
                st.error(f"‚ùå Erro: {str(e)}")
                logger.error(f"Basic upload error: {e}")


def _render_emergency_upload_fallback(s3_manager, db_manager, username: str):
    """Fallback de emerg√™ncia - ultra b√°sico"""
    try:
        st.header("üì§ Upload de Emerg√™ncia")
        st.warning("Sistema b√°sico de emerg√™ncia ativo")
        
        uploaded_file = st.file_uploader("Arquivo:", type=None, key="emergency_upload")
        
        if uploaded_file is not None:
            if st.button("Upload", type="primary", key="emergency_button"):
                try:
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    file_key = f"{username}/{timestamp}_{uploaded_file.name}"
                    
                    if s3_manager.upload_file(uploaded_file, file_key):
                        st.success("‚úÖ Upload realizado")
                    else:
                        st.error("‚ùå Erro no upload")
                        
                except Exception as e:
                    st.error(f"Erro: {str(e)}")
                    
    except Exception as e:
        st.error(f"Erro cr√≠tico: {str(e)}")
        logger.error(f"Emergency upload error: {e}")


# Log de inicializa√ß√£o
logger.info("‚úÖ Concurrent upload UI loaded successfully with error handling")
