#!/usr/bin/env python3
"""
Script de Corre√ß√£o dos Relat√≥rios
Execute: python fix_reports.py
"""
import os
import sys
import shutil
from datetime import datetime

def fix_reports():
    """Corrige os arquivos de relat√≥rios"""
    
    print("üîß CORRIGINDO SISTEMA DE RELAT√ìRIOS")
    print("=" * 50)
    
    # 1. Criar backup
    backup_dir = f"backup_fix_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    os.makedirs(backup_dir, exist_ok=True)
    
    files_to_backup = [
        'admin_reports_data.py',
        'enhanced_admin_reports.py',
        'admin_pages.py'
    ]
    
    for file in files_to_backup:
        if os.path.exists(file):
            shutil.copy2(file, os.path.join(backup_dir, file))
            print(f"‚úÖ Backup: {file}")
    
    print(f"üìÅ Backup criado em: {backup_dir}")
    print()
    
    # 2. Sobrescrever admin_reports_data.py
    print("üìù Atualizando admin_reports_data.py...")
    
    admin_reports_data_content = '''"""
Implementa√ß√µes Completas das Fun√ß√µes de Dados para Relat√≥rios - VERS√ÉO CORRIGIDA
Arquivo: admin_reports_data.py
Corrige erro de sintaxe e problemas com DataFrames
"""
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

def _get_file_types_distribution(db_manager, period_days):
    """Distribui√ß√£o de tipos de arquivo"""
    conn = _get_db_connection_safe(db_manager)
    if not conn:
        return pd.DataFrame(columns=['file_type', 'count'])
    
    try:
        cursor = conn.cursor()
        
        period_filter = ""
        if period_days:
            period_filter = f"WHERE uploaded_at >= NOW() - INTERVAL '{period_days} days'"
        
        cursor.execute(f"""
            SELECT 
                CASE 
                    WHEN mime_type LIKE 'image/%' THEN 'Imagem'
                    WHEN mime_type LIKE 'video/%' THEN 'V√≠deo'
                    WHEN mime_type LIKE 'audio/%' THEN '√Åudio'
                    WHEN mime_type LIKE 'text/%' THEN 'Texto'
                    WHEN mime_type LIKE 'application/pdf' THEN 'PDF'
                    WHEN mime_type LIKE 'application/vnd.ms-%' OR mime_type LIKE 'application/vnd.openxmlformats%' THEN 'Office'
                    WHEN mime_type LIKE 'application/zip%' OR mime_type LIKE 'application/x-%' THEN 'Arquivo'
                    ELSE 'Outros'
                END as file_type,
                COUNT(*) as count
            FROM files 
            {period_filter}
            GROUP BY 
                CASE 
                    WHEN mime_type LIKE 'image/%' THEN 'Imagem'
                    WHEN mime_type LIKE 'video/%' THEN 'V√≠deo'
                    WHEN mime_type LIKE 'audio/%' THEN '√Åudio'
                    WHEN mime_type LIKE 'text/%' THEN 'Texto'
                    WHEN mime_type LIKE 'application/pdf' THEN 'PDF'
                    WHEN mime_type LIKE 'application/vnd.ms-%' OR mime_type LIKE 'application/vnd.openxmlformats%' THEN 'Office'
                    WHEN mime_type LIKE 'application/zip%' OR mime_type LIKE 'application/x-%' THEN 'Arquivo'
                    ELSE 'Outros'
                END
            ORDER BY count DESC
        """)
        
        results = cursor.fetchall()
        cursor.close()
        conn.close()
        
        if results:
            return pd.DataFrame(results, columns=['file_type', 'count'])
        else:
            return pd.DataFrame(columns=['file_type', 'count'])
            
    except Exception as e:
        logger.error(f"Error getting file types distribution: {e}")
        if conn:
            conn.close()
    
    return pd.DataFrame(columns=['file_type', 'count'])


# Fun√ß√£o auxiliar para conex√£o de banco
def _get_db_connection_safe(db_manager):
    """Obt√©m conex√£o segura com o banco"""
    try:
        if db_manager:
            return db_manager.get_connection()
        else:
            from database import DatabaseManager
            from config import Config
            db_manager = DatabaseManager(Config.DATABASE_URL)
            return db_manager.get_connection()
    except Exception as e:
        logger.error(f"Database connection error: {e}")
        return None


def _get_detailed_user_metrics(db_manager, period_days):
    """M√©tricas detalhadas de usu√°rios"""
    metrics = {'new_users': 0, 'active_users': 0, 'recent_logins': 0, 'retention_rate': 0}
    
    conn = _get_db_connection_safe(db_manager)
    if not conn:
        return metrics
    
    try:
        cursor = conn.cursor()
        
        # Novos usu√°rios no per√≠odo
        if period_days:
            cursor.execute(f"""
                SELECT COUNT(*) FROM users 
                WHERE created_at >= NOW() - INTERVAL '{period_days} days' AND is_active = TRUE
            """)
            metrics['new_users'] = cursor.fetchone()[0] or 0
        
        # Usu√°rios ativos (login nos √∫ltimos 7 dias)
        cursor.execute("""
            SELECT COUNT(*) FROM users 
            WHERE last_login >= NOW() - INTERVAL '7 days' AND is_active = TRUE
        """)
        metrics['active_users'] = cursor.fetchone()[0] or 0
        
        # Logins recentes (√∫ltimas 24h)
        cursor.execute("""
            SELECT COUNT(*) FROM users 
            WHERE last_login >= NOW() - INTERVAL '1 day' AND is_active = TRUE
        """)
        metrics['recent_logins'] = cursor.fetchone()[0] or 0
        
        # Taxa de reten√ß√£o
        cursor.execute("""
            SELECT 
                COUNT(CASE WHEN last_login IS NOT NULL THEN 1 END) * 100.0 / NULLIF(COUNT(*), 0) as retention_rate
            FROM users 
            WHERE is_active = TRUE
        """)
        retention_result = cursor.fetchone()
        metrics['retention_rate'] = float(retention_result[0]) if retention_result[0] else 0
        
        cursor.close()
        conn.close()
        
    except Exception as e:
        logger.error(f"Error getting detailed user metrics: {e}")
        if conn:
            conn.close()
    
    return metrics


def _get_login_activity_by_hour(db_manager, period_days):
    """Atividade de login por hora do dia"""
    conn = _get_db_connection_safe(db_manager)
    if not conn:
        return pd.DataFrame({'hour': range(24), 'logins': [0]*24})
    
    try:
        cursor = conn.cursor()
        
        period_filter = ""
        if period_days:
            period_filter = f"WHERE last_login >= NOW() - INTERVAL '{period_days} days'"
        
        cursor.execute(f"""
            SELECT 
                EXTRACT(HOUR FROM last_login) as hour,
                COUNT(*) as logins
            FROM users 
            {period_filter}
            AND last_login IS NOT NULL
            GROUP BY EXTRACT(HOUR FROM last_login)
            ORDER BY hour
        """)
        
        results = cursor.fetchall()
        cursor.close()
        conn.close()
        
        if results:
            df = pd.DataFrame(results, columns=['hour', 'logins'])
            # Preencher horas faltantes com 0
            all_hours = pd.DataFrame({'hour': range(24)})
            df = all_hours.merge(df, on='hour', how='left').fillna(0)
            return df
        else:
            return pd.DataFrame({'hour': range(24), 'logins': [0]*24})
            
    except Exception as e:
        logger.error(f"Error getting login activity by hour: {e}")
        if conn:
            conn.close()
    
    return pd.DataFrame({'hour': range(24), 'logins': [0]*24})


# Fun√ß√µes placeholder simples para evitar erros
def _get_users_by_weekday(db_manager, period_days):
    return pd.DataFrame(columns=['weekday', 'users'])

def _get_most_active_users(db_manager, period_days):
    return []

def _get_activity_heatmap_data(db_manager, period_days):
    return np.zeros((7, 24))

def _get_detailed_file_metrics(db_manager, period_days):
    return {'total_uploads': 0, 'avg_file_size': 0, 'total_downloads': 0, 'download_rate': 0}

def _get_file_sizes_distribution(db_manager, period_days):
    return pd.DataFrame(columns=['size_mb'])

def _get_storage_timeline(db_manager, period_days):
    return pd.DataFrame(columns=['date', 'daily_uploads', 'cumulative_uploads', 'daily_gb', 'cumulative_gb'])

def _get_top_uploaders(db_manager, period_days):
    return []

def _get_security_metrics(db_manager, period_days):
    return {'login_attempts': 0, 'failed_logins': 0, 'login_success_rate': 100, 'unique_ips': 0}

def _get_login_attempts_by_hour(db_manager, period_days):
    return pd.DataFrame({'hour': range(24), 'attempts': [0]*24})

def _get_mfa_statistics(db_manager):
    return pd.DataFrame(columns=['mfa_status', 'count'])

def _get_top_ips_activity(db_manager, period_days):
    return []

def _get_security_alerts(db_manager, period_days):
    return []

def _get_performance_metrics(db_manager, period_days):
    return {'avg_upload_time': 0, 'avg_download_time': 0, 'upload_success_rate': 100, 'peak_concurrent_users': 0}

def _get_response_times_timeline(db_manager, period_days):
    return pd.DataFrame(columns=['timestamp', 'avg_response_time'])

def _get_upload_size_performance(db_manager, period_days):
    return pd.DataFrame(columns=['file_size_mb', 'upload_time'])

def _get_hourly_system_usage(db_manager, period_days):
    return pd.DataFrame(columns=['hour', 'uploads', 'downloads', 'logins'])


logger.info("‚úÖ Admin reports data functions loaded successfully")
'''
    
    with open('admin_reports_data.py', 'w', encoding='utf-8') as f:
        f.write(admin_reports_data_content)
    
    print("‚úÖ admin_reports_data.py corrigido")
    
    # 3. Atualizar admin_pages.py
    print("üìù Atualizando admin_pages.py...")
    
    try:
        with open('admin_pages.py', 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Verificar se j√° tem a fun√ß√£o
        if 'render_advanced_reports_section' not in content:
            # Adicionar fun√ß√£o
            function_to_add = '''

def render_advanced_reports_section(username: str, user_manager=None):
    """Renderiza se√ß√£o de relat√≥rios avan√ßados com gr√°ficos"""
    
    try:
        # Importar sistema de relat√≥rios avan√ßados
        from enhanced_admin_reports import render_enhanced_reports_section
        from database import DatabaseManager
        from config import Config
        
        # Inicializar database manager
        db_manager = DatabaseManager(Config.DATABASE_URL)
        
        # Renderizar relat√≥rios avan√ßados
        render_enhanced_reports_section(username, user_manager, db_manager)
        
    except ImportError as import_error:
        logger.error(f"Enhanced reports not available: {import_error}")
        st.error("‚ùå Sistema de relat√≥rios avan√ßados n√£o dispon√≠vel")
        st.info("Execute: pip install plotly pandas numpy")
        
        # Fallback para relat√≥rios b√°sicos
        st.warning("üìä Usando relat√≥rios b√°sicos como alternativa")
        render_reports_section(username, user_manager)
        
    except Exception as e:
        logger.error(f"Advanced reports error: {e}")
        st.error(f"‚ùå Erro nos relat√≥rios avan√ßados: {e}")
        
        # Tentar relat√≥rios b√°sicos como fallback
        try:
            render_reports_section(username, user_manager)
        except Exception as fallback_error:
            st.error(f"‚ùå Erro tamb√©m nos relat√≥rios b√°sicos: {fallback_error}")
'''
            
            # Atualizar navega√ß√£o
            if '["dashboard", "users", "files", "reports", "logs"]' in content:
                content = content.replace(
                    '["dashboard", "users", "files", "reports", "logs"]',
                    '["dashboard", "users", "files", "reports", "advanced_reports", "logs"]'
                )
            
            # Atualizar format_func
            if '"reports": "üìà Relat√≥rios",' in content:
                content = content.replace(
                    '"reports": "üìà Relat√≥rios",',
                    '"reports": "üìà Relat√≥rios B√°sicos",\n                "advanced_reports": "üìä Relat√≥rios Avan√ßados",'
                )
            
            # Adicionar elif
            if '''elif page == 'reports':
            render_reports_section(username, user_manager)
        elif page == 'logs':''' in content:
                content = content.replace(
                    '''elif page == 'reports':
            render_reports_section(username, user_manager)
        elif page == 'logs':''',
                    '''elif page == 'reports':
            render_reports_section(username, user_manager)
        elif page == 'advanced_reports':
            render_advanced_reports_section(username, user_manager)
        elif page == 'logs':'''
                )
            
            # Adicionar fun√ß√£o
            content += function_to_add
            
            with open('admin_pages.py', 'w', encoding='utf-8') as f:
                f.write(content)
            
            print("‚úÖ admin_pages.py atualizado")
        else:
            print("‚úÖ admin_pages.py j√° tem integra√ß√£o")
    
    except Exception as e:
        print(f"‚ùå Erro ao atualizar admin_pages.py: {e}")
    
    # 4. Teste final
    print("\nüß™ Testando corre√ß√µes...")
    
    try:
        import admin_reports_data
        import enhanced_admin_reports
        print("‚úÖ M√≥dulos importados com sucesso")
        
        import plotly
        import pandas
        import numpy
        print("‚úÖ Depend√™ncias funcionando")
        
        print("\nüéâ CORRE√á√ÉO CONCLU√çDA COM SUCESSO!")
        print("\nüìã Pr√≥ximos passos:")
        print("1. Reinicie sua aplica√ß√£o Streamlit")
        print("2. Acesse Administra√ß√£o > Relat√≥rios Avan√ßados")
        print("3. Teste os gr√°ficos e m√©tricas")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erro no teste: {e}")
        print("üí° Tente instalar as depend√™ncias:")
        print("pip install plotly pandas numpy")
        return False

if __name__ == "__main__":
    try:
        success = fix_reports()
        sys.exit(0 if success else 1)
    except Exception as e:
        print(f"‚ùå Erro cr√≠tico: {e}")
        sys.exit(1)
